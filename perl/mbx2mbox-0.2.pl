#!/usr/bin/perl -w # # {{{ Header # Author: Reini Urban # Created: <2000-04-22 11:26:16 rurban> # Time-stamp: <2005-02-01 18:00:08 rurban> # Description: # Converts Outlook Express .mbx to unix mailbox format. #	It just strips the binary header markers and adds a Netscape #	acceptable "From" field at the start of the mail header. #	It optionally removes some unneeded header entries ("Received"). # Usage: mbx2mbox [options] infile >outfile # Options: #	-noReceive remove all "Receive" entries #	-noX remove all "X-" header fields # -keepcrlf don't convert DOS CR+LF end-of-line to UNIX LF # URL: ftp://xarch.tu-graz.ac.at/pub/autocad/urban/perl/ # Copyright: 2000 Reini Urban # You may copy, redistribute it and/or modify it under the #	same terms as Perl itself. # $Log: $ # v0.2 2005-02-01 15:30:00 Andrew Kanaber # -convert date with Date::Parse to cope with unusual Date: headers (the # day-of-week is optional in RFC822 dates), also handle Draft mails etc with # no Date: header #	-match headers (Date: etc) case insensitively #	-chomp body twice (with $/="\r\n") before adding "\r\n\r\n" to avoid padding # it #	-translate \r\n -> \n unless "-keepcrlf" option set #	-get address from From: if available and do From address instead of From - #	-fail for unrecognised commandline option # # }}} ######################################################################### # {{{ Init use strict; use Date::Parse; use vars qw (@ARGV $VERSION $noReceive $noX $keepcrlf); ( $VERSION ) = '$Revision: 0.2 $ ' =~ /\$Revision:\s+([^\s]+)/; # Options: while ($ARGV[0] =~ /^-(.*)/) { $noReceive++, shift, next if $1 eq 'noReceive'; $noX++, shift, next if $1 eq 'noX'; $keepcrlf++, shift, next if $1 eq 'keepcrlf'; die "mbx2mbox: unknown option $1\n"; } # }}} # {{{ mbx format reverse engineered # sample: 71 msg's, msg1-text: 100 (0x64), len: 0x45676 (284280), # msg1-bin: 0x53 # header: # 0-3: 'JMF6' # 4: 0x0003 0001, (long: 65539) short, 3 # 6: short, 1 # 8: long, number of msg (0x47, 71) # C: long, number of msg (0x47, 71) # 10: short 0x5678 # 12: 0x0004 0001 (long: 65540) short 4 # 14: short 1 # .. # # 53-63: msg1-bin # 53 0x00 or multiple 0x00 (alignment bytes) # 54: 0x7f007f00 (sentinel) # 58: long (0x1, 1) (msg id) # 5c: long (0x28c, 652) (msg-size + binhdr 17) # 60: long (0x27b, 635) (msg size) # 64-2df: msg1-text #	msg-hdr: 0x64-0x260 (0x1fc, 508) #	msg-body: 0x260-0x2df (0x7f, 127) # msg: 0x64-0x2df (0x27b, 635) # 2df-2ef: msg2-bin #	00, # 2e0 0x7f007f00 (sentinel) # long 2 id #	long 0x394, 916 msg-size + hdr #	long 0x381, 897 raw msg-size # 2f0-671: msg2-text # msg3-bin # 672: 0000 (alignment bytes) # 674: 7f007f00 # 678: 3xlong (id, size+hdr, raw size) # }}} # {{{ Functions sub mbx_header { my ($buf, $nmsg, $nmsg_h); die "empty file: $!\n" unless sysread (MBX, $buf, 4); die "no Outlook Express mbx format: $!\n" unless 'JMF6' eq $buf; sysread (MBX, $buf, 4); (65539 == unpack ("l", $buf)) or warn "HEADER: expected 0x03000100: $!\n"; sysread (MBX, $buf, 4); $nmsg = unpack ("l", $buf); sysread (MBX, $buf, 4); $nmsg_h = unpack ("l", $buf); sysread (MBX, $buf, 2); ('xV' eq $buf) or warn ("HEADER: expected 0x8765, got ", unpack ("h4", $buf), ": $!\n"); sysread (MBX, $buf, 4); (65540 == unpack ("l", $buf)) or warn "HEADER: expected 0x04000100: $!\n"; sysread (MBX, $buf, 0x3d); # chunk 00, reserved for future? return ($nmsg, $nmsg_h); } sub next_msg { my $i = shift; my ($buf, $id, $rawsize, $fullsize); # warning: any 0x1a in the input stream will abort sysread! sysread (MBX, $buf, 1);	# 00 filler bytes until f7 while ( $buf eq "\c@" ) { sysread (MBX, $buf, 1);	# 00 filler bytes until f7 last if $buf eq "\c?";	# 0xf7 } ($buf eq "\c?") or warn "MSG# $i: expected 0x00f7: $!\n"; sysread (MBX, $buf, 2);	# sentinel ('00f7' eq unpack ("h4", $buf)) or warn "MSG# $i: expected sentinel 0xf700f7: $!\n"; sysread (MBX, $buf, 4);	# id $id = unpack ("l", $buf); if ($id != $i) { warn "MSG# $i: unexpected msg id $id: $!\n"; } # if ($id == 14) { # print STDERR "!"; } sysread (MBX, $buf, 4); $fullsize = unpack ("l", $buf); sysread (MBX, $buf, 4); $rawsize = unpack ("l", $buf); if (!$fullsize or !$rawsize) { my $p = tell (MBX); die ("MSG# $id: couldn't read msg size from \"$buf\" ", "at $p(0x", sprintf("%x", $p), "): $!\n"); } else { print STDERR "MSG# $id: $fullsize bytes\n"; } sysread (MBX, $buf, $rawsize); return ($buf, $id, $fullsize, $rawsize); } # convert date from RFC822 format to UNIX date(1) format sub cvt_date { my $date = shift; my $unixtime = str2time($date); if(!defined($unixtime)) { print STDERR "Date header not found\n"; $unixtime = 0; } return gmtime($unixtime); } sub cvt_from { local $_ = shift; if( /<(.+?)>/ ) { return $1; } elsif( /([^ @()]+[@][^ @()]+)/ ) { return $1; } else { return "-"; } } sub fix_msg_buf { my $buf = shift; my ($date, $from, $hdr, @body, $body, $mail); ($hdr, @body) = split (/\r\n\r\n/, $buf); $body = join "\r\n\r\n", @body; $hdr = $hdr . "\r\n"; chomp $body;chomp $body; $body .= "\r\n\r\n"; # body should end with empty line # "From " should be the first line unless ($hdr =~ /^From /) { $hdr =~ /^Date:\s+(.+?)\r\n/im; $date = cvt_date ($1); $hdr =~ /^From:\s+(.+?)\r\n/im; $from = cvt_from ($1); $hdr = "From $from $date\r\n" . $hdr; } if ($noReceive) { $hdr =~ s/^Received: .*?\n\s+.*?\n\s+.*?\n\s+.*?\n\s+.*?\n//mg; $hdr =~ s/^Received: .*?\n\s+.*?\n\s+.*?\n\s+.*?\n//mg; $hdr =~ s/^Received: .*?\n\s+.*?\n\s+.*?\n//mg; $hdr =~ s/^Received: .*?\n\s+.*?\n//mg; $hdr =~ s/^Received: .*?\n//mg; } if ($noX) { $hdr =~ s/^X-[a-z_\-]+: .*\n//img; } $mail = $hdr . "\r\n" . $body; $mail =~ s/\r\n/\n/g unless $keepcrlf; return $mail; } # }}} # {{{ Top-Level use Fcntl; sysopen MBX, $ARGV[0], O_RDONLY|O_BINARY; binmode(STDOUT); $/="\r\n"; my ($buf, $n, $i); $i = 0; ($n) = mbx_header(); while ($i < $n) { $i++; ($buf) = next_msg ($i); print fix_msg_buf ($buf); } # }}}
